<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithms on Aaditya</title>
    <link>https://aaditya2200.github.io/algorithms/</link>
    <description>Recent content in Algorithms on Aaditya</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>Â© Aaditya</copyright>
    <lastBuildDate>Tue, 04 Feb 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://aaditya2200.github.io/algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tries</title>
      <link>https://aaditya2200.github.io/algorithms/algorithms/tries/</link>
      <pubDate>Tue, 04 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://aaditya2200.github.io/algorithms/algorithms/tries/</guid>
      <description>&lt;h2 id=&#34;tries&#34;&gt;Tries&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;When to use?&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;To find common prefixes.&lt;/li&gt;&#xA;&lt;li&gt;To verify existence of words within a set of strings&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;In real world systems, tries are used in autocomplete&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;types-of-problems&#34;&gt;Types of problems&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Implementation of trie&lt;/li&gt;&#xA;&lt;li&gt;Wildcard search&lt;/li&gt;&#xA;&lt;li&gt;Find all words on a board&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;Please use this &lt;a href=&#34;https://leetcode.com/discuss/general-discussion/853098/trie-or-search-related-question-and-good-explanation&#34;&gt;resource&lt;/a&gt; for practice.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;problems&#34;&gt;Problems&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/implement-trie-prefix-tree&#34;&gt;Trie Implementation&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Use a map to store pointers from ch to TrieNode&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Improvement&lt;/strong&gt;: use a &lt;code&gt;TrieNode*&lt;/code&gt; array of 26 length. Access each char by subtracting &lt;code&gt;a&lt;/code&gt; from it.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/design-add-and-search-words-data-structure/&#34;&gt;Wildcard Search&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Be careful. The base case for recursion should be when &lt;code&gt;index == word.size()&lt;/code&gt; this is because when you start at root, index is 0, and you are searching the next level for character 0. Meaning, for each index, you are searching the next level, and not the current level. That is why the standard string condition of &lt;code&gt;size - 1&lt;/code&gt; fails. Remember that the root is essentially a dummy node.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/word-search-ii/&#34;&gt;Word Search 2&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;This is a bit tricky. The idea is simple, but the implementation is tricky&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/prefix-and-suffix-search/&#34;&gt;Prefix Suffix Search&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Straightforward. Insert all prefixes and suffixed. For example, for &lt;code&gt;apple&lt;/code&gt;, we insert &lt;code&gt;a#apple, ap#apple, ... apple#apple, #apple, e#apple, le#apple&lt;/code&gt; etc.&lt;/li&gt;&#xA;&lt;li&gt;Maintain index of the word as you encounter them. &lt;code&gt;apple&lt;/code&gt; would have index 0.&lt;/li&gt;&#xA;&lt;li&gt;Maybe dont even need prefix&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Prefix Sum</title>
      <link>https://aaditya2200.github.io/algorithms/algorithms/prefix-sum/</link>
      <pubDate>Sun, 02 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://aaditya2200.github.io/algorithms/algorithms/prefix-sum/</guid>
      <description>&lt;h1 id=&#34;what-kind-of-problems&#34;&gt;What Kind Of Problems?&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Sum of ranges.&lt;/li&gt;&#xA;&lt;li&gt;Ranges with k-sum.&lt;/li&gt;&#xA;&lt;li&gt;Product of all indices except current.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Refer to &lt;a href=&#34;https://leetcode.com/discuss/study-guide/5119937/Prefix-Sum-Problems&#34;&gt;resource&lt;/a&gt; for practice problems.&lt;/p&gt;&#xA;&lt;h2 id=&#34;progress&#34;&gt;Progress&lt;/h2&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/range-sum-query-immutable/description/&#34;&gt;303. Range Sum Query - Immutable&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/subarray-sum-equals-k/description/&#34;&gt;560. Subarray Sum Equals K&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;This problem is interesting. We keep track of the frequency of the prefix sums in a map.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/xor-queries-of-a-subarray/&#34;&gt;1310. XOR Queries of a Subarray&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;This required some thinking, but turns out we can find XOR of a range by taking a prefix array of XORs and computing XOR for the required range indices.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/count-vowel-strings-in-ranges/description/&#34;&gt;2559. Count Vowel Strings in Ranges&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;This threw me off at first, but after looking at it for a minute, realized it&amp;rsquo;s nothing fancy.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/description/&#34;&gt;325. Maximum Size Subarray Sum Equals k&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;This is a variation of the standard pattern. You store index instead of frequency.&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/count-number-of-nice-subarrays/description/&#34;&gt;1248. Count Number of Nice Subarrays&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Fumbled a little bit here. Found two ways to solve this.&lt;/strong&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Convert the array into 0 and 1 for even and odd.&lt;/li&gt;&#xA;&lt;li&gt;Keep track of counts in a map and update when &lt;code&gt;count - k&lt;/code&gt; is found.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/binary-subarrays-with-sum/description/&#34;&gt;930. Binary Subarrays With Sum&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Same as above. However, surprisingly not the fastest in LeetCode.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;11&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/count-number-of-bad-pairs/description/&#34;&gt;2364. Count Number of Bad Pairs&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Need to revisit. The logic is as follows:&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Total pairs is &lt;code&gt;n * (n - 1) / 2&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;For each number in the list, compute &lt;code&gt;i - nums[i]&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;Subtract the map value for this index from total pairs.&lt;/li&gt;&#xA;&lt;li&gt;Increment map value.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Why does this work? ðŸ¤”&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;12&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/&#34;&gt;1658. Minimum Operations to Reduce X to Zero&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;This was pretty tough to understand, but once I did, it was relatively straightforward.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;13&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/subarray-sums-divisible-by-k/&#34;&gt;974. Subarray Sums Divisible by K&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;This uses the same concept as the basic problem. But, I. need to be careful as to what the question asks for. They didnt ask for subarrays summing to k. They asked for subarrays divisible by k.&lt;/li&gt;&#xA;&lt;li&gt;The formula: &lt;code&gt;sum = (((sum + item) % k) + k)%k&lt;/code&gt; is important to avoid negative reminders.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;14&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/&#34;&gt;1497. Check If Array Pairs Are Divisible by k&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;This was tricky. The classic approach does not seem to work for me. What I did, was store all remainders in a map, and then check if all the remainder pairs have the same count. If they dont, the answer is false.&lt;/li&gt;&#xA;&lt;li&gt;If the number of 0 remainders is not even, the answer is false. Why? Well, it&amp;rsquo;s simple. lets say &lt;code&gt;k = 7&lt;/code&gt;, and we have two number &lt;code&gt;7&lt;/code&gt; and &lt;code&gt;21&lt;/code&gt;. If the sum of these 2 numbers is divisible by &lt;code&gt;k&lt;/code&gt;, the number of zero remainders is even. Tldr, if there exists one number with the remainder 0, the only way that the sum is divisible by 0 is if another number with remainder 0 exists.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;15&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/make-sum-divisible-by-p/description/&#34;&gt;1590. Make Sum Divisible by P&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;This was tricky. The main idea is as follows:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;We find the total sum, and check if it is divisible by p. if it is, return 0.&lt;/li&gt;&#xA;&lt;li&gt;Else, we need to find the subarray which sums up to &lt;code&gt;total sum % p&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Now, we compute prefix sum. For each element, we find &lt;code&gt;pref % p&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;We need to remove the elements from the array, such that the sum of the subarray is divisible by p. The formula for this is &lt;code&gt;target = (curr - rem + p) % p&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;If found in map, update lengths.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;16&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/continuous-subarray-sum/&#34;&gt;523. Continuous Subarray Sum&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;I was able to figure this one out. Need to be more careful with respect to if and else condition and updating the map.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;17&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/find-the-divisibility-array-of-a-string/description/&#34;&gt;2575. Find the Divisibility Array of a String&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;This was easy. But there is a formula I should use: &lt;code&gt;new_rem = (old_rem * 10 + digit) % m&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;18&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/count-of-interesting-subarrays/description/&#34;&gt;2845. Count of Interesting Subarrays&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Like 9, first convert to 1 and 0. Then for each num, try to find its complement in the map.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;19&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/description/&#34;&gt;1442. Count Triplets That Can Form Two Arrays of Equal XOR&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Use this math formula to understand whats going on.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;prefix[i] .... ^ prefix[j-1] = prefix[j] ^ prefix[i]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;prefix[j] ..... prefix[k] = prefix[k + 1] ^ prefix[j]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;equating both and eliminating prefix[j]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
