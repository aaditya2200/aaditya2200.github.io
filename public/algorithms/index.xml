<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithms on Aaditya</title>
    <link>http://localhost:1313/algorithms/</link>
    <description>Recent content in Algorithms on Aaditya</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>Â© Aaditya</copyright>
    <lastBuildDate>Sun, 02 Feb 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Prefix Sum</title>
      <link>http://localhost:1313/algorithms/algorithms/prefix-sum/</link>
      <pubDate>Sun, 02 Feb 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/algorithms/algorithms/prefix-sum/</guid>
      <description>&lt;h1 id=&#34;what-kind-of-problems&#34;&gt;What Kind Of Problems?&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Sum of ranges.&lt;/li&gt;&#xA;&lt;li&gt;Ranges with k-sum.&lt;/li&gt;&#xA;&lt;li&gt;Product of all indices except current.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Refer to &lt;a href=&#34;https://leetcode.com/discuss/study-guide/5119937/Prefix-Sum-Problems&#34;&gt;resource&lt;/a&gt; for practice problems.&lt;/p&gt;&#xA;&lt;h2 id=&#34;progress&#34;&gt;Progress&lt;/h2&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/range-sum-query-immutable/description/&#34;&gt;303. Range Sum Query - Immutable&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/subarray-sum-equals-k/description/&#34;&gt;560. Subarray Sum Equals K&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;This problem is interesting. We keep track of the frequency of the prefix sums in a map.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/xor-queries-of-a-subarray/&#34;&gt;1310. XOR Queries of a Subarray&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;This required some thinking, but turns out we can find XOR of a range by taking a prefix array of XORs and computing XOR for the required range indices.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/count-vowel-strings-in-ranges/description/&#34;&gt;2559. Count Vowel Strings in Ranges&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;This threw me off at first, but after looking at it for a minute, realized it&amp;rsquo;s nothing fancy.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/description/&#34;&gt;325. Maximum Size Subarray Sum Equals k&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;This is a variation of the standard pattern. You store index instead of frequency.&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/count-number-of-nice-subarrays/description/&#34;&gt;1248. Count Number of Nice Subarrays&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Fumbled a little bit here. Found two ways to solve this.&lt;/strong&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Convert the array into 0 and 1 for even and odd.&lt;/li&gt;&#xA;&lt;li&gt;Keep track of counts in a map and update when &lt;code&gt;count - k&lt;/code&gt; is found.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/binary-subarrays-with-sum/description/&#34;&gt;930. Binary Subarrays With Sum&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Same as above. However, surprisingly not the fastest in LeetCode.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;11&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/count-number-of-bad-pairs/description/&#34;&gt;2364. Count Number of Bad Pairs&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Need to revisit. The logic is as follows:&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Total pairs is &lt;code&gt;n * (n - 1) / 2&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;For each number in the list, compute &lt;code&gt;i - nums[i]&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;Subtract the map value for this index from total pairs.&lt;/li&gt;&#xA;&lt;li&gt;Increment map value.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Why does this work? ðŸ¤”&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;12&#34;&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/&#34;&gt;1658. Minimum Operations to Reduce X to Zero&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;This was pretty tough to understand, but once I did, it was relatively straightforward.&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
